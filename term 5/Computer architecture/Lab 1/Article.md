# Хеш-функции: область применения, виды, особенности.
## Словарь
- Хеш-функция (функция свёртывания) – алгоритм, который путем математических вычислений преобразовывает входные данные произвольной длины в выходные данные фиксированной длины.
- Хеш (хеш-сумма)– набор бит, полученный в результате применения хеш-функции.
- Коллизия – явление, при котором хеш-функция выдает одинаковый хеш при разных входных данных.
## Общая информация
Как обеспечить надежное хранение паролей, проверить целостность данных и ускорить работу алгоритма? Во всем этом может помочь хеш-функция, а как именно - рассмотрим в этой статье.
Простым примером хеш-функции может служить деление по модулю. Однако, в реальности используются более сложные математические алгоритмы.
Базовые требования к хеш-функциям:
1. Хеш – всегда фиксированного размера
2. Одинаковые входные данные всегда дают одинаковый хеш
3. Разные данные выдают разный хеш*

*Под 3 пунктом подразумевается сведение коллизий к минимуму за счет подбора подходящего алгоритма хеширования. Полностью избежать данного явления невозможно, так как на вход хеш-функция принимает данные любого размера, а вывод должен быть фиксированной длины. Подробнее важность минимизации коллизий будет рассмотрена при классификации хеш-функций.

### Примеры использования в коде хеш-функции SHA-256
Ниже можно увидеть пример на разных языках программирования простой программы, в которой мы задаем строку, передаем её хеш-функции и отображаем полученный в результате преобразования вывод:

**Java:**

```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class HashExample {
    public static void main(String[] args) throws NoSuchAlgorithmException {
        String data = "Hello, Hash!";

        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(data.getBytes());

        // Преобразование байтов хеша в шестнадцатеричную строку
        StringBuilder hexString = new StringBuilder();
        for (byte b : hash)
            hexString.append(String.format("%02x", b));

        System.out.println(hexString);
    }
}
```

**Python:**

```python
import hashlib

data = "Hello, Hash!"
hash_object = hashlib.sha256(data.encode())
hash_hex = hash_object.hexdigest()

print(hash_hex)
```

**JavaScript:**

```javascript
const crypto = require('crypto');

const data = "Hello, Hash!";
const hash = crypto.createHash('sha256').update(data).digest('hex');

console.log(hash);
```

Вывод всех программ будет одинаковым, так как в них используется одна и та же хеш-функция с одинаковыми входными данными (2 пункт требований к хеш-функциям):

```2932639bd3e3dd545ebda5fa3db5b976b7d7e3ee73a171b3c5fa003ed3d988c9```

Если заменим входную строку на “Hello, World!”, то получим другой результат (3 пункт требований к хеш-функциям):

```dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f```

При этом размер полученных хешей совпадает (1 пункт требований к хеш-функциям).

Использованный в данном примере Sha-256 – лишь одна из реализаций хеш-функций, их существует большое множество и они отличаются между собой по:
1) Области применения
2) Длине вывода
3) Способу построения
4) Криптографической стойкости
5) Алгоритму
6) Скорости вычисления
7) Равномерности распределения хеша

## Основные области применения хеш-функций

### Алгоритмы и структуры данных
Примеры использования:
1) Хеш-таблицы
2) Множества (sets)
3) Хеш-деревья
4) Индексация баз данных
5) Алгоритмы поиска по схожести (например, сравнение хешей картинок, вместо попиксельного сравнения значительно ускоряет процесс)
6) и др.

Рассмотрим принцип работы хеш-таблиц (ассоциативных словарей). Мы можем сохранять в словарь пары ключ-значение. После этого по введенному ключу получаем нужные нам данные. Но при чем тут хеш-функция и какая ей роль?

Когда мы создаем словарь - внутри него создается массив ячеек размером n. Затем, когда мы помещаем в словарь ключ со значением, ключ пропускается через хеш-функцию, таким образом мы получаем индекс в массиве (также происходит делению по модулю на n, чтобы индекс не выходил за пределы массива). По этому индексу помещается значение. Затем, когда мы ищем в словаре данные по ключу - он опять пропускается через хеш-функцию и мы получаем индекс, по которому расположены наши данные. Таким образом, поиск данных в хеш-таблице работает за время O(1), что значительно быстрее линейного поиска (O(n)), т.к. мы сразу можем вычислить индекс нужной нам ячейки.

Тут мы сталкиваемся с коллизиями. Разные ключи могут выдавать одинаковый хеш, в таком случае они попадают в одну ячейку. Это возможно, т.к. в ячейке на самом деле хранится не просто значение, а список значений, которые в нее попали (зависит от реализации, часто также используются деревья). В данном случае **коллизии значительно замедляют поиск**, т.к. скорость прохождения по списку - O(n). И чем больше значений в списке, тем медленнее поиск. 

В итоге процесс поиска в словаре выглядит следующим образом: получаем индекс ячейки, пропуская ключ через хеш-функцию. Затем в ячейке с заданным индексом находим список и в нем уже последовательно сравниваем ключи, чтобы найти искомое значение. 

Предположим, мы делаем простое приложение для изучения алфавита. Нам нужно хранить 33 пары ключ-значение, где ключ - буква, а значение - слово на эту букву. Сравним несколько хеш-функций, на основании которых можно организовать работу словаря:
1) Хеш-функция, которая для любого ключа будет выдавать индекс = 1. То есть, все значения, которые мы поместим в словарь, будут попадать в одну и ту же ячейку. Соответственно, в один и тот же список. Таким образом, получение элементов из словаря сильно замедлится и будет равно O(n).
2) Хеш-функция, которая преобразует первую букву ключа (в данном случае ключ и так состоит из 1 буквы) в индекс, согласно алфавиту (т.е, а -> 1, в -> 3, я -> 33). В таком случае мы получим отсутствие коллизий и идеальное распределение - в каждой ячейке будет находится по одному значению. Получается, оптимальная хеш-функция найдена.

Теперь используем эту же хеш-функцию в приложении для складского учета. В качестве ключа будет название предмета, а в качестве значения - его кол-во на складе:

Помним, функция преобразует первую букву ключа в индекс, согласно алфавиту (т.е, апельсин -> 1, виноград -> 3, яблоко -> 33). Тут мы сталкиваемся со случаем, когда несколько наименований могут начинаться с одной буквы (апельсины, ананасы, абрикосы и т.д.) и мы снова сталкиваемся с коллизиями. Если так получится, что на складе хранятся наименования, большинство из которых начинается на одну и ту же букву, то скорость поиска в словаре снова начинает стремиться к времени O(n). 

**Но если бы рядовому программисту под каждую задачу приходилось разрабатывать отдельную хеш-функцию, то время разработки сильно бы затягивалось. Поэтому под каждую типовую задачу уже существуют оптимальные решения.**

Для словарей, например, специально было разработано семейство функций **CityHash** от Google. Основными критериями при разработке были:
1) Быстрота вычислений. Это важно, т.к. если в хеш-функции будет избыточная логика, которая замедляет вычисление хеша хотя-бы на 1 мс, то на каждой 1000 обращений к словарю будет секунда лишних вычислений, что может быть критическим показателем для высоконагруженных систем.
2) Равномерность распределений. Данное семейство хеш-функций дает высокий показатель равномерности распределений, когда мы не можем знать входные данные заранее и считаем их случайными.

Для наглядности - бенчмарк скорости вычисления CityHash в сравнении с другими хеш-функциями того же назначения:

Как видно из графиков, CityHash показывает один из лучших результатов. 
Также стоит отметить, что в пределах этого семейства конкретные хеш-функции оптимизированы под определенные длины входных данных.

**Вывод №1: выбор плохой хеш функции может значительно замедлить работу алгоритма. Как было показано в примере, время поиска по словарю O(1) может превратиться в O(n).**

### Криптография
Примеры применения хеш-функций в криптографии: 
1) Цифровые подписи
2) Хранение паролей
3) Блокчейн и криптовалюты
4) Токены аутентификации
и др.
Рассмотрим важность хеш-функции на примере хранения паролей.

Если хранить пароли в открытом виде (т.е. не хешируя), то злоумышленник, получив доступ к базе данных, может без проблем украсть пароль и воспользоваться им для получения конфиденциальных данных. Чтобы этого избежать, пароли хранятся в хешированном виде. А когда пользователь вводит пароль - он хешируется и сравнивается с тем, который лежит в базе данных. 

Тут мы снова сталкиваемся с **опасностью коллизий**. Злоумышленник может подобрать такие данные, которые при хешировании дадут одинаковый с паролем хеш. Как следствие - можно ввести эти данные вместо пароля и получить доступ к чужому аккаунту. 

Чтобы избежать подобного рода опасностей, к криптографическим хеш-функциям есть дополнительные требования:
1) Стойкость к коллизиям. Это означает, что нет эффективного полиномиального алгоритма, позволяющего находить коллизии.
2) Сопротивлению поиску прообраза. Хеш-функция должна быть односторонней - т.е. должна отсутствовать возможность восстановить входные данные по хешу.
3) Чувствительность к изменениям. Небольшие изменения во входных данных должны приводить к существенным изменениям в хеш-значении. 

Самые популярные представители криптографических хеш-функций - семейства MD и SHA.

Однако, на данный момент не рекомендуется использование всех функций семейства MD, а также функции SHA-1. Это связано с несколькими причинами:
1) Уязвимости к коллизиям: MD5 и SHA-1 были подвергнуты атакам, позволяющим находить коллизии - различные наборы данных, дающие одинаковый хеш-код. Это делает их небезопасными для для использования в области криптографии. Так происходит из-за недостаточная длины хеш-значения. Например, в MD5 размер хеша составляет 128 бит, соответственно уникальных хешей существует всего 2^128. Если же использовать функции с размером хеша 256 бит, это уменьшит шанс коллизии приблизительно в 10^38 раз.
2) Быстрая вычислительная атака: MD5 и SHA-1 стали уязвимы к атакам, использующим быстрые методы вычисления. Это означает, что злоумышленники могут относительно легко создавать фальшивые данные с теми же хеш-значениями.

**Какие хеш-функции тогда стоит использоватьв в области криптографии?** На данный момент стандартом безопасности и универсальным вариантом является SHA-3, т.к. в нем были исправлены все вышеперечисленные недостатки. Однако, универсальный вариант - это всегда компромисс. Для конкретных задач лучше использовать специализированные инструменты.

Так, например, для хранения паролей была специально разработана хеш-функция bcrypt. И вот почему она идеально подходит для этих целей:
1) Медленность и стоимость: Bcrypt специально сделана так, чтобы быть медленной и требовательной к ресурсам. Это означает, что процесс хеширования пароля занимает значительное количество времени, что делает атаки методом перебора с использованием словаря или ускоренных аппаратных средств (ASICs, GPU) гораздо менее эффективными.
2) Соль (Salt): Bcrypt включает в себя автоматическую генерацию и использование уникальной соли для каждого пароля. Соль представляет собой случайное значение, добавляемое к паролю перед хешированием. Это устраняет возможность использования "таблиц радужных хешей" для атак вида "precomputed attacks", где заранее вычисленные хеши сопоставляются с сохраненными хешами.
3) Адаптивность к вычислительной мощности: Алгоритм Bcrypt может быть легко настроен для адаптации к растущей вычислительной мощности с течением времени. Это означает, что вы можете увеличивать количество итераций (рабочих факторов), требуемых для хеширования пароля, по мере улучшения производительности аппаратных средств.

**Вывод №2: выбор ненадежной хеш функции может привести к серьезным проблемам безопасности системы.**

