# Хеш-функции: область применения, виды, особенности

## Глоссарий

- Хеш-функция (функция свёртывания) – алгоритм, который путем математических вычислений преобразовывает входные данные произвольной длины в выходные данные фиксированной длины.
- Хеш (хеш-сумма)– набор бит, полученный в результате применения хеш-функции.
- Коллизия – явление, при котором хеш-функция выдает одинаковый хеш при разных входных данных.

## Общая информация

Как обеспечить надежное хранение паролей, проверить целостность данных и ускорить работу алгоритма? Во всем этом может помочь хеш-функция, а как именно - рассмотрим в этой статье.
Простым примером хеш-функции может служить деление по модулю. Однако, в реальности используются более сложные математические алгоритмы.
Базовые требования к хеш-функциям:

1. Хеш – всегда фиксированного размера
2. Одинаковые входные данные всегда дают одинаковый хеш
3. Разные данные выдают разный хеш*

*Под 3 пунктом подразумевается сведение коллизий к минимуму за счет подбора подходящего алгоритма хеширования. Полностью избежать данного явления невозможно, так как на вход хеш-функция принимает данные любого размера, а вывод должен быть фиксированной длины. Подробнее важность минимизации коллизий будет рассмотрена при классификации хеш-функций.

### Примеры использования в коде хеш-функции SHA-256

Ниже можно увидеть пример на разных языках программирования простой программы, в которой мы задаем строку, передаем её хеш-функции и отображаем полученный в результате преобразования вывод:

**Java:**

```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class HashExample {
    public static void main(String[] args) throws NoSuchAlgorithmException {
        String data = "Hello, Hash!";

        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(data.getBytes());

        // Преобразование байтов хеша в шестнадцатеричную строку
        StringBuilder hexString = new StringBuilder();
        for (byte b : hash)
            hexString.append(String.format("%02x", b));

        System.out.println(hexString);
    }
}
```

**Python:**

```python
import hashlib

data = "Hello, Hash!"
hash_object = hashlib.sha256(data.encode())
hash_hex = hash_object.hexdigest()

print(hash_hex)
```

**JavaScript:**

```javascript
const crypto = require('crypto');

const data = "Hello, Hash!";
const hash = crypto.createHash('sha256').update(data).digest('hex');

console.log(hash);
```

Вывод всех программ будет одинаковым, так как в них используется одна и та же хеш-функция с одинаковыми входными данными (2 пункт требований к хеш-функциям):

```2932639bd3e3dd545ebda5fa3db5b976b7d7e3ee73a171b3c5fa003ed3d988c9```

Если заменим входную строку на “Hello, World!”, то получим другой результат (3 пункт требований к хеш-функциям):

```dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f```

При этом размер полученных хешей совпадает (1 пункт требований к хеш-функциям).

Использованный в данном примере Sha-256 – лишь одна из реализаций хеш-функций, их существует большое множество и они отличаются между собой по:

1) Области применения
2) Длине вывода
3) Способу построения
4) Криптографической стойкости
5) Алгоритму
6) Скорости вычисления
7) Равномерности распределения хеша

## Основные области применения хеш-функций

### Алгоритмы и структуры данных

Примеры использования:

1) Хеш-таблицы
2) Множества (sets)
3) Хеш-деревья
4) Индексация баз данных
5) Алгоритмы поиска по схожести (например, сравнение хешей картинок, вместо попиксельного сравнения значительно ускоряет процесс)
6) и др.

Рассмотрим принцип работы хеш-таблиц (ассоциативных словарей). Мы можем сохранять в словарь пары ключ-значение. После этого по введенному ключу получаем нужные нам данные. Но при чем тут хеш-функция и какая её роль?

Когда мы создаем словарь - внутри него создается массив ячеек размером n. Затем, когда мы помещаем в словарь ключ со значением, ключ пропускается через хеш-функцию, таким образом мы получаем индекс в массиве (также происходит делению по модулю на n, чтобы индекс не выходил за пределы массива). По этому индексу помещается значение. Затем, когда мы ищем в словаре данные по ключу - он опять пропускается через хеш-функцию и мы получаем индекс, по которому расположены наши данные. Таким образом, поиск данных в хеш-таблице работает за время O(1), что значительно быстрее линейного поиска (O(n)), т.к. мы сразу можем вычислить индекс нужной нам ячейки.

Тут мы сталкиваемся с коллизиями. Разные ключи могут выдавать одинаковый хеш, в таком случае они попадают в одну ячейку. Это возможно, т.к. в ячейке на самом деле хранится не просто значение, а список* значений, которые в нее попали. В данном случае **коллизии значительно замедляют поиск**, т.к. скорость прохождения по списку - O(n). И чем больше значений в списке, тем медленнее поиск.

*- Зависит от реализации, часто также используются деревья

В итоге процесс поиска в словаре выглядит следующим образом: получаем индекс ячейки, пропуская ключ через хеш-функцию. Затем в ячейке с заданным индексом находим список и в нем уже последовательно сравниваем ключи, чтобы найти искомое значение.

Предположим, мы делаем простое приложение для изучения алфавита. Нам нужно хранить 33 пары ключ-значение, где ключ - буква, а значение - слово на эту букву. Сравним несколько хеш-функций, на основании которых можно организовать работу словаря:

1) Хеш-функция, которая для любого ключа будет выдавать индекс = 1. То есть, все значения, которые мы поместим в словарь, будут попадать в одну и ту же ячейку. Соответственно, в один и тот же список. Таким образом, получение элементов из словаря сильно замедлится и будет равно O(n).
2) Хеш-функция, которая преобразует первую букву ключа (в данном случае ключ и так состоит из 1 буквы) в индекс, согласно алфавиту (т.е, а -> 1, в -> 3, я -> 33). В таком случае мы получим отсутствие коллизий и идеальное распределение - в каждой ячейке будет находится по одному значению. Получается, оптимальная хеш-функция найдена.

Теперь используем эту же хеш-функцию в приложении для складского учета. В качестве ключа будет название предмета, а в качестве значения - его кол-во на складе:

Помним, функция преобразует первую букву ключа в индекс, согласно алфавиту (т.е, апельсин -> 1, виноград -> 3, яблоко -> 33). Тут мы сталкиваемся со случаем, когда несколько наименований могут начинаться с одной буквы (апельсины, ананасы, абрикосы и т.д.) и мы снова сталкиваемся с коллизиями. Если так получится, что на складе хранятся наименования, большинство из которых начинается на одну и ту же букву, то скорость поиска в словаре снова начинает стремиться к времени O(n).

Но если бы рядовому программисту под каждую задачу приходилось разрабатывать отдельную хеш-функцию, то время разработки сильно бы затягивалось. **Поэтому под каждую типовую задачу уже существуют оптимальные решения.**

Для словарей, например, идеально подходит семейство функций **CityHash** от Google, так как оно соответствует необходимым критериям:

1) Быстрота вычислений. Это важно, т.к. если в хеш-функции будет избыточная логика, которая замедляет вычисление хеша хотя-бы на 1 мс, то на каждой 1000 обращений к словарю будет секунда лишних вычислений, что может быть критическим показателем для высоконагруженных систем.
2) Равномерность распределений. Данное семейство хеш-функций дает высокий показатель равномерности распределений, когда мы не можем знать входные данные заранее и считаем их случайными.

Также стоит отметить, что в пределах этого семейства конкретные хеш-функции оптимизированы под определенные длины входных данных.

**Вывод №1: выбор плохой хеш функции может значительно замедлить работу алгоритма. Как было показано в примере, время поиска по словарю O(1) может превратиться в O(n).**

### Криптография

Примеры применения хеш-функций в криптографии:

1) Цифровые подписи
2) Хранение паролей
3) Блокчейн и криптовалюты
4) Токены аутентификации
5) и др.

Рассмотрим важность хеш-функции на примере хранения паролей. Если хранить их в открытом виде (т.е. не хешируя), то злоумышленник, получив доступ к базе данных, может без проблем украсть пароль и воспользоваться им для получения конфиденциальных данных. Чтобы этого избежать, пароли хранятся в хешированном виде. А когда пользователь вводит пароль - он хешируется и сравнивается с хешем, который лежит в базе данных.

Тут мы снова сталкиваемся с **опасностью коллизий**. Злоумышленник может подобрать такие данные, которые при хешировании дадут одинаковый с паролем хеш. Как следствие - можно ввести эти данные вместо пароля и получить доступ к чужому аккаунту.

Чтобы избежать подобного рода опасностей, к криптографическим хеш-функциям есть дополнительные требования:

1) Стойкость к коллизиям. Это означает, что не должно быть эффективного полиномиального алгоритма, позволяющего находить коллизии.
2) Сопротивлению поиску прообраза. Хеш-функция должна быть односторонней - т.е. должна отсутствовать возможность восстановить входные данные по хешу.
3) Чувствительность к изменениям. Небольшие изменения во входных данных должны приводить к существенным изменениям в хеш-значении.

Самые популярные представители криптографических хеш-функций - семейства MD и SHA.

Однако, на данный момент не рекомендуется использование всех функций семейства MD, а также функции SHA-1. Это связано с несколькими причинами:

1) Уязвимости к коллизиям: MD5 и SHA-1 были подвергнуты атакам, позволяющим находить коллизии - различные наборы данных, дающие одинаковый хеш-код. Это делает их небезопасными для для использования в области криптографии. Так происходит из-за недостаточной длины хеш-значения. Например, в MD5 размер хеша составляет 128 бит, соответственно уникальных хешей существует всего 2^128. Если же использовать функции с размером хеша 256 бит, это уменьшит шанс коллизии приблизительно в 10^38 раз.
2) Быстрая вычислительная атака: MD5 и SHA-1 стали уязвимы к атакам, использующим быстрые методы вычисления. Это означает, что злоумышленники могут относительно легко создавать фальшивые данные с теми же хеш-значениями.

**Какие хеш-функции тогда стоит использовать в области криптографии?** На данный момент стандартом безопасности и универсальным вариантом является SHA-3, т.к. в нем были исправлены все вышеперечисленные недостатки. Однако, универсальный вариант - это всегда компромисс. Для конкретных задач лучше использовать специализированные инструменты.

Так, например, для хранения паролей была специально разработана хеш-функция bcrypt. И вот почему она идеально подходит для этих целей:

1) Медленность и стоимость: Bcrypt специально сделана так, чтобы быть медленной и требовательной к ресурсам. Это означает, что процесс хеширования пароля занимает значительное количество времени, что делает атаки методом перебора с использованием словаря или ускоренных аппаратных средств (ASICs, GPU) гораздо менее эффективными.
2) Соль: Bcrypt включает в себя автоматическую генерацию и использование уникальной соли для каждого пароля. Она представляет собой случайное значение, добавляемое к паролю перед хешированием. Это устраняет возможность использования "таблиц радужных хешей" для атак вида "precomputed attacks", где заранее вычисленные хеши сопоставляются с сохраненными хешами.
3) Адаптивность к вычислительной мощности: Алгоритм Bcrypt может быть легко настроен для адаптации к растущей вычислительной мощности с течением времени. Это означает, что можно увеличивать количество итераций, требуемых для хеширования пароля, по мере улучшения производительности аппаратных средств.

**Вывод №2: выбор ненадежной хеш функции может привести к серьезным проблемам безопасности системы.**

### Целостность данных

Сложно представить приложение, в котором не происходила бы передача данных. Отправка сообщения другу, открытие страницы браузера, просмотр видео, заполнение формы авторизации - все это процессы, в которых задействованы получение/передача данных. И никому не хочется, чтобы бы в форме авторизации был введен один пароль, а на сервер пришел другой, как следствие повреждения данных. Это приведет к невозможности доступа к аккаунту.

Поэтому для проверки целостности информации был придуман механизм контрольных сумм. Одна из разновидностей контрольных сумм - хеш.
Перед отправкой данных, к ним в конец дописывается контрольная сумма. Затем,  принимающая сторона также составляет контрольную сумму полученных данных и сравнивает с той, которая была отправлена. Если они не совпадают - значит данные повреждены и необходимо их повторно запросить.

В этой области применение нашло семейство хеш-функций CRC (именно они используются в Ethernet). И этому есть ряд причин:

1) Простота и эффективность. Это позволяет быстро и легко создавать контрольные суммы для данных.
2) Хорошая распределенность ошибок. Это означает, что случайные ошибки имеют высокую вероятность обнаружения.
3) Возможность выбора параметров. Можно настраивать функцию под конкретные требования системы.

**Вывод №3: плохая хеш-функции может привести к невозможности обнаружения поврежденных данных.**

## Общий вывод

Выбор хеш-функции зависит, прежде всего, от поставленных целей и области применения. Где-то требуется простота алгоритма, а где-то он, наоборот, искусственно усложняется. Где-то криптографическая стойкость критична, а где-то ей можно пренебречь. В некоторых местах можно обойтись небольшой длиной хеша, а в некоторых это недопустимо. Поэтому нужно делать выбор, учитывая специфику поставленной задачи.
