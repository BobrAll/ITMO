# Хеш-функции: область применения, виды, особенности.
## Словарь
- Хеш-функция (функция свёртывания) – алгоритм, который путем математических вычислений преобразовывает входные данные произвольной длины в выходные данные фиксированной длины.
- Хеш (хеш-сумма)– набор бит, полученный в результате применения хеш-функции.
- Коллизия – явление, при котором хеш-функция выдает одинаковый хеш при разных входных данных.
## Общая информация
Как обеспечить надежное хранение паролей, проверить целостность данных и ускорить работу алгоритма? Во всем этом может помочь хеш-функция, а как именно - рассмотрим в этой статье.
Простым примером хеш-функции может служить деление по модулю. Однако, в реальности используются более сложные математические алгоритмы.
Базовые требования к хеш-функциям:
1. Хеш – всегда фиксированного размера
2. Одинаковые входные данные всегда дают одинаковый хеш
3. Разные данные выдают разный хеш*

*Под 3 пунктом подразумевается сведение коллизий к минимуму за счет подбора подходящего алгоритма хеширования. Полностью избежать данного явления невозможно, так как на вход хеш-функция принимает данные любого размера, а вывод должен быть фиксированной длины. Подробнее важность минимизации коллизий будет рассмотрена при классификации хеш-функций.

### Примеры использования в коде хеш-функции SHA-256
Ниже можно увидеть пример на разных языках программирования простой программы, в которой мы задаем строку, передаем её хеш-функции и отображаем полученный в результате преобразования вывод:

**Java:**

```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class HashExample {
    public static void main(String[] args) throws NoSuchAlgorithmException {
        String data = "Hello, Hash!";

        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(data.getBytes());

        // Преобразование байтов хеша в шестнадцатеричную строку
        StringBuilder hexString = new StringBuilder();
        for (byte b : hash)
            hexString.append(String.format("%02x", b));

        System.out.println(hexString);
    }
}
```

**Python:**

```python
import hashlib

data = "Hello, Hash!"
hash_object = hashlib.sha256(data.encode())
hash_hex = hash_object.hexdigest()

print(hash_hex)
```

**JavaScript:**

```javascript
const crypto = require('crypto');

const data = "Hello, Hash!";
const hash = crypto.createHash('sha256').update(data).digest('hex');

console.log(hash);
```

Вывод всех программ будет одинаковым, так как в них используется одна и та же хеш-функция с одинаковыми входными данными (2 пункт требований к хеш-функциям):

```2932639bd3e3dd545ebda5fa3db5b976b7d7e3ee73a171b3c5fa003ed3d988c9```

Если заменим входную строку на “Hello, World!”, то получим другой результат (3 пункт требований к хеш-функциям):

```dffd6021bb2bd5b0af676290809ec3a53191dd81c7f70a4b28688a362182986f```

При этом размер полученных хешей совпадает (1 пункт требований к хеш-функциям).

Использованный в данном примере Sha-256 – лишь одна из реализаций хеш-функций, их существует большое множество и они отличаются между собой по:
1) Области применения
2) Длине вывода
3) Способу построения
4) Криптографической стойкости
5) Алгоритму
6) Скорости вычисления
7) Равномерности распределения хеша

## Применение хеш-функций в разных областях

### Алгоритмы и структуры данных
Примеры использования:
1) Хеш-таблицы
2) Множества (sets)
3) Хеш-деревья
4) Индексация баз данных
5) Алгоритмы поиска по схожести (например, сравнение хешей картинок, вместо попиксельного сравнения значительно ускоряет процесс)
6) и др.

Рассмотрим принцип работы хеш-таблиц (ассоциативных словарей). Мы можем сохранять в словарь пары ключ-значение. После этого по введенному ключу получаем нужные нам данные. Но при чем тут хеш-функция и какая ей роль?

Когда мы создаем словарь - внутри него создается массив ячеек размером n. Затем, когда мы помещаем в словарь ключ со значением, ключ пропускается через хеш-функцию, таким образом мы получаем индекс в массиве (также происходит делению по модулю на n, чтобы индекс не выходил за пределы массива). По этому индексу помещается значение. Затем, когда мы ищем в словаре данные по ключу - он опять пропускается через хеш-функцию и мы получаем индекс, по которому расположены наши данные. Таким образом, поиск данных в хеш-таблице работает за время O(1), что значительно быстрее линейного поиска (O(n)), т.к. мы сразу можем вычислить индекс нужной нам ячейки.

Но тут мы опять сталкиваемся с коллизиями. Разные ключи могут выдавать одинаковый хеш. В таком случае оба значения попадают в одну ячейку. Это возможно, т.к. в ячейке на самом деле хранится не просто значение, а *связанный список значений (вместе с ключами). 

*- Зависит от конкретной реализации, часто вместо списков используются деревья

В итоге процесс поиска в словаре выглядит следующим образом: получаем индекс ячейки, пропуская ключ через хеш-функцию. Затем в ячейке с заданным индексом находим список и в нем уже последовательно сравниваем ключи, чтобы найти искомое значение. 

Предположим, мы делаем простое приложение для изучения алфавита. Нам нужно хранить 33 пары ключ-значение, где ключ - буква, а значение - слово на эту букву. Сравним несколько хеш-функций, на основании которых можно организовать работу словаря:
1) Хеш-функция, которая для любого ключа будет выдавать индекс = 1. То есть, все значения, которые мы поместим в словарь, будут попадать в одну и ту же ячейку. Соответственно, в один и тот же список. Таким образом, получение элементов из словаря сильно замедлится, т.к. время поиска в списке - O(n).
2) Хеш-функция, которая преобразует первую букву ключа (в данном случае ключ и так состоит из 1 буквы) в индекс, согласно алфавиту (т.е, а -> 1, в -> 3, я -> 33). В таком случае мы получим отсутствие коллизий и идеальное распределение - в каждой ячейке будет находится по одному значению. Получается оптимальная хеш-функция найдена.

Теперь используем эту же хеш-функцию в приложении для складского учета. В качестве ключа будет название предмета, а в качестве значения - его кол-во на складе:

Помним, функция преобразует первую букву ключа в индекс, согласно алфавиту (т.е, апельсин -> 1, виноград -> 3, яблоко -> 33). Тут мы сталкиваемся со случаем, когда несколько наименований могут начинаться с одной буквы (апельсины, ананасы, абрикосы и т.д.) и мы снова сталкиваемся с коллизиями. Если так получится, что на складе хранятся наименования, большинство из которых начинается на одну и ту же букву, то скорость поиска в словаре снова начинает стремиться к времени O(n). 

Но если бы рядовому программисту под каждую задачу приходилось разрабатывать отдельную хеш-функцию, то время разработки сильно бы затягивалось. Поэтому под каждую типовую задачу уже существуют оптимальные хеш-функции.

Для словарей, например, специально было разработано семейство функций CityHash от Google. Основными критериями при разработке были:
1) Быстрота вычислений. Это важно, т.к. если в хеш-функции будет избыточная логика, которая замедляет вычисление хеша хотя-бы на 1 мс, то на каждой 1000 обращений к словарю будет секунда лишних вычислений, что может быть критическим показателем для высоконагруженных систем.
2) Равномерность распределений. Данное семейство хеш-функций дает высокий показатель равномерности распределений, когда мы не можем знать входные данные заранее и считаем их случайными.

Для наглядности - бенчмарк скорости вычисления CityHash в сравнении с другими хеш-функциями того же назначения:

Как видно из графиков, CityHash показывает один из лучших результатов. 
Также стоит отметить, что в пределах этого семейства конкретные хеш-функции оптимизированы под определенные интервалы длины входных данных.

**Вывод №1: выбор плохой хеш функции может значительно замедлить работу алгоритма. Как было показано в примере, время поиска по словарю O(1) может превратиться в O(n).**

